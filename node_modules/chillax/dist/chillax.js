"use strict";
/*

CHILLAX — vertical parallax engine

*/
Object.defineProperty(exports, "__esModule", { value: true });
var parallax_utilities_1 = require("./parallax-utilities");
/**
 * CHILLAX — vertical parallax engine
 *
 * - provide 'view' elements to apply parallax effects within
 *   they should have the `[data-chillax]` attribute, which describes 'leeway',
 *   the percentage of parallax sliding action allowable, relative to the
 *   height of the view
 *
 * - parallax effect will be applied to child elements of the views which have
 *   the `[data-chillax-layer]` attribute
 *
 * - the numerical value of the `[data-chillax-layer]` attribute will define
 *   the speed and direction of the parallax effect
 *
 * - the parallax effect is achieved by the application of css `transform`
 *   rules using the `translate3d` css feature
 */
var Chillax = /** @class */ (function () {
    /** Create a chillax instance which applies parallax effects onto the
        provided html element 'views' */
    function Chillax(_a) {
        var _b = _a.views, views = _b === void 0 ? [] : _b;
        var _this = this;
        /** Function handler to apply parallax effects to all 'layers' relative to
            their containing 'view' */
        this.applyParallax = function () {
            var scroll = parallax_utilities_1.getPageScroll();
            var viewportHeight = parallax_utilities_1.getViewportHeight();
            for (var _i = 0, _a = _this.views; _i < _a.length; _i++) {
                var _b = _a[_i], view = _b.view, layers = _b.layers, leeway = _b.leeway;
                var progress = parallax_utilities_1.getScrollProgressThroughElement({ scroll: scroll, viewportHeight: viewportHeight, element: view });
                var centeredProgress = (progress * 2) - 1;
                var viewHeight = view.offsetHeight;
                for (var _c = 0, layers_1 = layers; _c < layers_1.length; _c++) {
                    var layer = layers_1[_c];
                    var depth = parseFloat(layer.getAttribute("data-chillax-layer"));
                    var leewayPixels = (leeway / 100) * viewHeight;
                    // the money shot
                    var parallax = (centeredProgress * (leewayPixels / 2) * depth) / 10;
                    layer.style.transform = "translate3d(0px, " + parallax + "px, 0px)";
                }
            }
        };
        if (!views)
            throw new Error("chillax requires an array of views");
        this.views = parallax_utilities_1.makeArray(views).map(function (view) {
            var layers = parallax_utilities_1.makeArray(view.querySelectorAll("[data-chillax-layer]"));
            var leeway = parseFloat(view.getAttribute("data-chillax"));
            return { view: view, layers: layers, leeway: leeway };
        });
        window.addEventListener("scroll", this.applyParallax);
        window.addEventListener("resize", this.applyParallax);
        this.applyParallax();
    }
    /** Deactivate and shutdown this chillax instance and all associated
        parallax effects */
    Chillax.prototype.dispose = function () {
        window.removeEventListener("scroll", this.applyParallax);
        window.removeEventListener("resize", this.applyParallax);
    };
    return Chillax;
}());
exports.default = Chillax;
//# sourceMappingURL=chillax.js.map